<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Head-to-Head</title>
  <link rel="stylesheet" href="assets/styles.css" />
  <style>
    /* Tables inside card-body don't need sticky headers or corner radius */
    .card-body table thead th {
      position: static;
      box-shadow: none;
      border-radius: 0;
    }
    .card-body table tbody tr:last-child td {
      border-radius: 0;
    }
  </style>
</head>
<body>
  <div class="sitebar">
    <div class="bar-inner">
      <div class="brand">Season Ending Roster</div>
      <nav class="tabs" aria-label="Primary">
        <a href="index.html">Home</a>
        <a href="franchises.html">Franchises</a>
        <a href="playoffs.html">Playoffs</a>
        <a href="seasons/index.html">Seasons</a>
        <a href="h2h.html" aria-current="page">H2H</a>
        <a href="history.html">History</a>
      </nav>
    </div>
  </div>

  <div class="wrap">
    <div class="page-header">
      <h1>Head-to-Head</h1>
    </div>

    <div class="controls">
      <label>Owner A <select id="ownerA"></select></label>
      <label>Owner B <select id="ownerB"></select></label>
      <label><input type="checkbox" id="playoffsOnly" /> Playoffs only</label>
      <span class="count" id="note"></span>
    </div>

    <div class="grid grid-2 mb-2">
      <div class="card">
        <div class="card-body">
          <h2 class="mb-1">Summary</h2>
          <div id="summary" class="muted">Pick two franchises to see the record.</div>
        </div>
      </div>

      <div class="card">
        <div class="card-body">
          <h2 class="mb-1">Top Rivalries</h2>
          <table id="tblTop">
            <thead>
              <tr>
                <th>Owners</th>
                <th class="right">Games</th>
                <th class="right">W-L-T</th>
                <th class="right">PF</th>
                <th class="right">PA</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="card-body">
        <h2 class="mb-1">Game Log</h2>
        <table id="tblLog">
          <thead>
            <tr>
              <th>Season</th>
              <th>Week</th>
              <th>Owner A</th>
              <th class="right">Pts</th>
              <th>Owner B</th>
              <th class="right">Pts</th>
              <th>Result</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <footer class="site-footer" id="siteFoot">
    <div>&copy; 2004&ndash;<span id="footYear"></span> Season Ending Roster</div>
    <div class="foot-meta">
      Data <span class="v">v&mdash;</span> &bull; Updated <span class="u">&mdash;</span>
    </div>
  </footer>

  <script>
    // Set sticky offset
    (function setStickyOffset() {
      function apply() {
        const bar = document.querySelector('.sitebar');
        const h = bar ? Math.ceil(bar.getBoundingClientRect().height) : 60;
        document.documentElement.style.setProperty('--sticky-top', (h + 8) + 'px');
      }
      apply();
      window.addEventListener('resize', apply, { passive: true });
    })();
  </script>

  <script>
    (async function () {
      const CAND = (p) => [`data/processed/${p}`, `/data/processed/${p}`];
      async function fetchText(paths) {
        for (const p of paths) {
          try { const r = await fetch(p, { cache: "no-store" }); if (r.ok) return { text: await r.text(), path: p }; } catch {}
        }
        return { text: null, path: null };
      }

      function parseCSV(text) {
        const rows = []; let i = 0, cur = "", inQ = false;
        const push = () => { rows[rows.length - 1].push(cur); cur = ""; };
        const start = () => rows.push([]); start();
        while (i < text.length) {
          const c = text[i++];
          if (inQ) { if (c == '"') { if (text[i] == '"') { cur += '"'; i++; } else inQ = false; } else cur += c; }
          else { if (c == '"') inQ = true; else if (c == ',') push(); else if (c == '\r') { } else if (c == '\n') { push(); start(); } else cur += c; }
        }
        if (cur !== "" || rows[rows.length - 1].length) push(); if (rows[rows.length - 1].length === 0) rows.pop();
        const header = rows.shift(); if (!header) return [];
        return rows.map(r => Object.fromEntries(header.map((h, i) => [h, r[i] ?? ""])));
      }

      const num = x => (x === "" || x == null) ? null : Number(x);
      const esc = s => String(s).replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' }[m]));

      // Load matchups and standings
      const [mres, sres] = await Promise.all([
        fetchText(CAND("matchups.csv")),
        fetchText(CAND("standings_by_season.csv"))
      ]);

      if (!mres.text) { document.getElementById("summary").textContent = "matchups.csv not found."; return; }

      // Build team_key -> manager mapping from standings
      const managerMap = {};
      if (sres.text) {
        parseCSV(sres.text).forEach(r => {
          if (r.team_key && r.manager) managerMap[r.team_key] = r.manager;
        });
      }

      // Parse matchups - each row is one team's perspective of a game
      // We deduplicate by taking only the "home" side (where team_key < opp_key)
      const rawRows = parseCSV(mres.text);
      const games = [];
      const seen = new Set();

      for (const r of rawRows) {
        const season = r.season;
        const week = num(r.week);
        const teamKey = r.team_key;
        const oppKey = r.opp_key;
        const ptsFor = num(r.pts_for);
        const ptsAgainst = num(r.pts_against);

        // Create unique game key (sorted to dedupe)
        const gameKey = `${season}-${week}-${[teamKey, oppKey].sort().join('-')}`;
        if (seen.has(gameKey)) continue;
        seen.add(gameKey);

        // Get manager names, fallback to team_name
        const ownerA = managerMap[teamKey] || r.team_name || teamKey;
        const ownerB = managerMap[oppKey] || r.opp_name || oppKey;

        // Determine winner
        let winner = null;
        let tie = false;
        if (ptsFor != null && ptsAgainst != null) {
          if (ptsFor > ptsAgainst) winner = ownerA;
          else if (ptsAgainst > ptsFor) winner = ownerB;
          else tie = true;
        }

        games.push({
          season, week,
          A: ownerA, B: ownerB,
          ptsA: ptsFor, ptsB: ptsAgainst,
          winner, tie
        });
      }

      // Get unique owners sorted
      const owners = [...new Set(games.flatMap(g => [g.A, g.B]))].filter(Boolean).sort((a, b) => a.localeCompare(b));

      const ownerA = document.getElementById("ownerA"), ownerB = document.getElementById("ownerB"), playoffsOnly = document.getElementById("playoffsOnly");
      ownerA.innerHTML = owners.map(o => `<option value="${esc(o)}">${esc(o)}</option>`).join("");
      ownerB.innerHTML = owners.map(o => `<option value="${esc(o)}">${esc(o)}</option>`).join("");
      ownerA.value = owners[0] || ""; ownerB.value = owners[1] || owners[0] || "";

      // Deep links
      const q = new URLSearchParams(location.search);
      const qa = q.get('a'), qb = q.get('b');
      if (qa && owners.includes(qa)) ownerA.value = qa;
      if (qb && owners.includes(qb)) ownerB.value = qb;
      playoffsOnly.checked = q.get('playoffs') === '1';

      function syncURL() {
        const p = new URLSearchParams(location.search);
        p.set('a', ownerA.value);
        p.set('b', ownerB.value);
        if (playoffsOnly.checked) p.set('playoffs', '1'); else p.delete('playoffs');
        history.replaceState(null, '', `${location.pathname}?${p}`);
      }

      ['change', 'input'].forEach(evt => {
        ownerA.addEventListener(evt, () => { syncURL(); render(); });
        ownerB.addEventListener(evt, () => { syncURL(); render(); });
      });
      playoffsOnly.addEventListener('change', () => { syncURL(); render(); });
      syncURL();

      // Top Rivalries (note: playoffs filter not applied to top rivalries)
      const pairKey = (x, y) => [x, y].sort().join(" vs ");
      const agg = {};
      for (const g of games) {
        const k = pairKey(g.A, g.B);
        if (!agg[k]) agg[k] = { A: g.A, B: g.B, games: 0, wA: 0, lA: 0, t: 0, pfA: 0, paA: 0 };
        const rec = agg[k];
        rec.games++;
        // Normalize points from A's perspective in the pair
        const isAFirst = g.A === rec.A;
        rec.pfA += (isAFirst ? g.ptsA : g.ptsB) || 0;
        rec.paA += (isAFirst ? g.ptsB : g.ptsA) || 0;
        if (g.tie) rec.t++;
        else if (g.winner === rec.A) rec.wA++;
        else if (g.winner === rec.B) rec.lA++;
      }
      const top = Object.entries(agg).map(([k, v]) => ({ owners: k, ...v })).sort((a, b) => b.games - a.games).slice(0, 10);
      document.querySelector("#tblTop tbody").innerHTML = top.map(r => `
        <tr>
          <td>${esc(r.owners)}</td>
          <td class="right">${r.games}</td>
          <td class="right">${r.wA}-${r.lA}-${r.t}</td>
          <td class="right">${(r.pfA).toFixed(1)}</td>
          <td class="right">${(r.paA).toFixed(1)}</td>
        </tr>`).join("");

      function render() {
        const A = ownerA.value, B = ownerB.value;
        // Note: playoffs filter disabled since we don't have playoff flag in CSV yet
        const filt = games.filter(g => (g.A === A && g.B === B) || (g.A === B && g.B === A))
          .sort((x, y) => (Number(x.season) - Number(y.season)) || ((x.week || 0) - (y.week || 0)));

        let wins = 0, losses = 0, ties = 0, pf = 0, pa = 0;
        const rows = filt.map(g => {
          const asA = (g.A === A);
          const myPts = asA ? g.ptsA : g.ptsB;
          const oppPts = asA ? g.ptsB : g.ptsA;
          const opp = asA ? g.B : g.A;
          pf += myPts || 0; pa += oppPts || 0;
          let res = "T";
          if (!g.tie && g.winner) {
            res = (g.winner === A) ? "W" : "L";
            if (res === "W") wins++; else losses++;
          } else if (g.tie) {
            ties++;
          }
          return `<tr>
            <td>${esc(g.season)}</td>
            <td>${g.week == null ? '&mdash;' : g.week}</td>
            <td>${esc(A)}</td><td class="right">${myPts == null ? '&mdash;' : myPts.toFixed(1)}</td>
            <td>${esc(opp)}</td><td class="right">${oppPts == null ? '&mdash;' : oppPts.toFixed(1)}</td>
            <td class="${res === 'W' ? 'win' : res === 'L' ? 'loss' : 'tie'}">${res}</td>
          </tr>`;
        }).join("");

        const gms = wins + losses + ties;
        const pct = gms ? ((wins + 0.5 * ties) / gms) : null;
        document.getElementById("summary").innerHTML =
          gms ? `<strong>${esc(A)}</strong> vs <strong>${esc(B)}</strong> &mdash; <span class="badge">${wins}-${losses}-${ties}</span>
                 &bull; Win% ${pct === null ? '&mdash;' : (pct * 100).toFixed(1)}%
                 &bull; PF ${pf.toFixed(1)} / PA ${pa.toFixed(1)}`
              : `No games between ${esc(A)} and ${esc(B)}.`;

        document.querySelector("#tblLog tbody").innerHTML = rows || `<tr><td class="muted" colspan="7">No games.</td></tr>`;
        document.getElementById("note").textContent = `${gms} games`;
      }

      render();
    })();
  </script>

  <script>
    // Footer
    document.getElementById('footYear').textContent = new Date().getFullYear();
    (async function () {
      const CAND = p => [`data/processed/${p}`, `/data/processed/${p}`];
      const tryFiles = [...CAND('playoff_metrics.json'), ...CAND('metrics.json')];
      async function firstOk(paths) {
        for (const url of paths) {
          try { const r = await fetch(url, { cache: 'no-store' }); if (r.ok) return { url, text: await r.text(), lm: r.headers.get('last-modified') }; } catch {}
        }
        return null;
      }
      const res = await firstOk(tryFiles);
      const vEl = document.querySelector('#siteFoot .v'), uEl = document.querySelector('#siteFoot .u');
      if (!res) { vEl.textContent = 'v&ndash;'; uEl.textContent = 'no data'; return; }
      const enc = new TextEncoder().encode(res.text);
      const buf = await crypto.subtle.digest('SHA-256', enc);
      const ver = Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('').slice(0, 8);
      vEl.textContent = 'v' + ver;
      uEl.textContent = res.lm ? new Date(res.lm).toLocaleString() : new Date().toLocaleString();
    })();
  </script>
</body>
</html>
