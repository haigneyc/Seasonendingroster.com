<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Playoff Brackets</title>
<style>
:root { --bg:#0f0f10; --card:#1b1b1d; --card2:#141416; --hover:#252528; --text:#fff; --line:#26262a; --muted:#9aa0a6; --stickyTop:56px; }
*{box-sizing:border-box} body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--text)}
/* Header tabs */
.sitebar{position:sticky;top:0;z-index:1000;width:100%;backdrop-filter:blur(8px);background:rgba(15,15,16,.85);border-bottom:1px solid var(--line)}
.bar-inner{margin:0 auto;max-width:1100px;padding:12px 20px;display:grid;grid-template-columns:1fr auto;gap:12px;align-items:center}
.brand{font-weight:700;letter-spacing:.2px}
.tabs{display:inline-flex;gap:6px;padding:6px;border:1px solid var(--line);border-radius:12px;background:var(--card2)}
.tabs a{color:var(--text);text-decoration:none;font-size:14px;padding:8px 12px;border-radius:8px;border:1px solid transparent}
.tabs a:hover{background:var(--hover);border-color:var(--line)}
.tabs a[aria-current="page"]{background:var(--card);border-color:var(--line)}
/* Page */
.wrap{max-width:1100px;margin:28px auto;padding:0 20px}
h1{margin:0 0 12px}
.row{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin:8px 0 12px}
select,input[type="checkbox"]{background:#121214;color:var(--text);border:1px solid #2a2a2e;border-radius:10px;padding:8px 10px}
.muted{color:var(--muted);font-size:12px}
.card{background:var(--card);border:1px solid var(--line);border-radius:16px;box-shadow:0 8px 20px rgba(0,0,0,.2);padding:12px}
/* Bracket layout */
.bracket{display:grid;gap:14px;grid-template-columns:repeat(auto-fit,minmax(240px,1fr))}
.round{background:#151518;border:1px solid #202024;border-radius:14px;padding:10px}
.round h3{margin:0 0 8px;font-size:14px;color:#cbd5e1}
.game{border:1px solid #2a2a2e;border-radius:12px;margin-bottom:10px;overflow:hidden;background:#141416}
.rowTeam{display:grid;grid-template-columns:auto 1fr auto;gap:8px;align-items:center;padding:8px 10px;border-bottom:1px solid #202024}
.rowTeam:last-child{border-bottom:none}
.seed{font-size:11px;opacity:.85;border:1px solid #2b2b30;border-radius:999px;padding:1px 6px}
.name{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.score{font-variation-settings:"wght" 600}
.win{background:#182318}
.tag{font-size:11px;opacity:.9;margin-left:6px;color:#a3e635}
.legend{margin:8px 0}
</style>
</head>
<body>
<!-- Top nav -->
<div class="sitebar">
  <div class="bar-inner">
    <div class="brand">Season Ending Roster</div>
    <nav class="tabs" aria-label="Primary">
      <a href="index.html">Home</a>
      <a href="franchises.html">Franchises</a>
      <a href="playoffs.html">Playoffs</a>
      <a href="brackets.html" aria-current="page">Brackets</a>
      <a href="h2h.html">H2H</a>
    </nav>
  </div>
</div>

<div class="wrap">
  <h1>Playoff Brackets</h1>
  <div class="row">
    <label>Season
      <select id="seasonSel"></select>
    </label>
    <label><input type="checkbox" id="showTeams"> Show team names (instead of franchise)</label>
    <span class="muted" id="note"></span>
  </div>
  <div class="muted legend">Winners are highlighted. Consolation (seeds 7–12) is hidden.</div>

  <div class="bracket" id="bracket"></div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const bar = document.querySelector('.sitebar');
  const h = bar ? Math.ceil(bar.getBoundingClientRect().height) : 56;
  document.documentElement.style.setProperty('--stickyTop', (h + 8) + 'px');
});
</script>

<script>
(async function(){
  // Paths helper (handles processed/proccessed and absolute/relative)
  const CAND = (p)=>[
    `data/processed/${p}`, `/data/processed/${p}`,
    `data/proccessed/${p}`, `/data/proccessed/${p}`
  ];

  async function fetchText(paths){
    for(const p of paths){ try{ const r=await fetch(p,{cache:'no-store'}); if(r.ok) return {text:await r.text(), path:p}; }catch{} }
    return {text:null, path:null};
  }
  async function fetchJSON(paths){
    for(const p of paths){ try{ const r=await fetch(p,{cache:'no-store'}); if(r.ok) return {json:await r.json(), path:p}; }catch{} }
    return {json:null, path:null};
  }
  function parseCSV(text){
    const rows=[]; let cur="", q=false, i=0; const out=[]; const push=()=>{rows[rows.length-1].push(cur);cur="";}; const start=()=>rows.push([]); start();
    while(i<text.length){ const c=text[i++]; if(q){ if(c=='"'){ if(text[i]=='"'){cur+='"';i++;} else q=false; } else cur+=c; }
      else{ if(c=='"') q=true; else if(c==',') push(); else if(c=='\r'){} else if(c=='\n'){push();start();} else cur+=c; } }
    if(cur!==""||rows[rows.length-1].length) push(); if(rows[rows.length-1].length===0) rows.pop();
    const header=rows.shift()||[]; return rows.map(r=>Object.fromEntries(header.map((h,j)=>[h, r[j]??""])));
  }
  const esc = s => String(s).replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m]));
  const num = x => (x===""||x==null)?null:Number(x);
  const boolish = v => String(v).trim().toLowerCase().match(/^(1|t|true|y|yes)$/);

  // ---------- Load matchups
  const mres = await fetchText(CAND("matchups.csv"));
  const bracketEl = document.getElementById("bracket");
  const note = document.getElementById("note");
  if(!mres.text){ bracketEl.innerHTML = '<div class="muted">No matchups.csv found.</div>'; return; }

  const raw = parseCSV(mres.text);

  // Normalize rows
  const gamesAll = raw.map(r=>{
    const flag = (r.is_playoffs ?? r.is_playoff ?? r.playoffs ?? r.playoff ?? r.phase ?? "").toString().trim().toLowerCase();
    const isPO = boolish(flag) || ["playoff","playoffs","post","postseason","p"].includes(flag);
    const roundName = (r.round ?? r.stage ?? "").toString().trim();
    let week = num(r.week); if (week==null && roundName) week = null;
    const A = (r.franchise_owner_a ?? r.owner_a ?? r.a_owner ?? "").trim();
    const B = (r.franchise_owner_b ?? r.owner_b ?? r.b_owner ?? "").trim();
    const tA = (r.team_name_a ?? r.team_a ?? "").trim();
    const tB = (r.team_name_b ?? r.team_b ?? "").trim();
    const pa = num(r.points_a ?? r.a_points);
    const pb = num(r.points_b ?? r.b_points);
    let winner = (r.winner_owner ?? "").trim();
    if(!winner && pa!=null && pb!=null){ winner = pa>pb ? A : pb>pa ? B : ""; }
    const tie = boolish(r.is_tie ?? r.tie) || (pa!=null && pb!=null && pa===pb);
    return { season:(r.season||"").trim(), week, roundName, is_playoffs:isPO, A,B,tA,tB, pa,pb, winner, tie };
  }).filter(g=>g.A && g.B);

  // Use flagged playoff games if present; else infer from last 2–3 weeks
  let playoffGames = gamesAll.filter(g=>g.is_playoffs);
  let modeNote = `Loaded ${playoffGames.length} flagged playoff games from ${esc(mres.path)}.`;
  if (playoffGames.length === 0) {
    const bySeason = {};
    for(const g of gamesAll){ (bySeason[g.season] ||= []).push(g); }
    playoffGames = [];
    Object.entries(bySeason).forEach(([season, gs])=>{
      const weeks = [...new Set(gs.map(x=>x.week).filter(w=>w!=null))].sort((a,b)=>a-b);
      if(weeks.length){
        const take = Math.min(3, Math.max(1, weeks.length>=2?2:1));
        const chosen = weeks.slice(-take);
        playoffGames.push(...gs.filter(x=>x.week!=null && chosen.includes(x.week)));
      }
    });
    modeNote = `No playoff flags found; inferred from last 2–3 weeks (${playoffGames.length} games).`;
  }

  // ---------- Seeds + champion
  let champs = {};
  const pm = await fetchJSON(CAND("playoff_metrics.json"));
  if (pm.json && pm.json.champions_by_season) champs = pm.json.champions_by_season;

  const sres = await fetchText(CAND("standings_by_season.csv"));
  const seeds = {};
  if (sres.text){
    const srows = parseCSV(sres.text);
    for(const r of srows){
      const season = r.season;
      const owner  = (r.franchise_owner || r.owner || "").trim();
      const seed   = r.playoff_seed===""?null:num(r.playoff_seed);
      (seeds[season] ||= {})[owner] = seed;
      const rk = r.rank===""?null:num(r.rank);
      if (rk===1 && !champs[season]) champs[season] = {franchise_owner: owner};
    }
  }

  // Filter out consolation: keep only games where BOTH teams are seeds 1..6
  const MAX_MAIN_SEED = 6;
  let filteredReason = "";
  if (Object.keys(seeds).length){
    const before = playoffGames.length;
    playoffGames = playoffGames.filter(g => {
      const sMap = seeds[g.season] || {};
      const sa = sMap[g.A], sb = sMap[g.B];
      if (sa == null || sb == null) return false;          // drop if seed unknown
      return sa <= MAX_MAIN_SEED && sb <= MAX_MAIN_SEED;   // keep true playoffs only
    });
    filteredReason = ` Showing only seeds 1–${MAX_MAIN_SEED} (removed ${before - playoffGames.length} consolation games).`;
  } else {
    filteredReason = ` (Could not load seeds; showing all playoff-tagged games.)`;
  }

  // ---------- Seasons & controls
  const seasons = [...new Set(playoffGames.map(g=>g.season))].sort((a,b)=>Number(a)-Number(b));
  const sel = document.getElementById("seasonSel");
  sel.innerHTML = seasons.map(s=>`<option value="${esc(s)}">${esc(s)}</option>`).join("");
  if (seasons.length) sel.value = seasons[seasons.length-1];

  const showTeams = document.getElementById("showTeams");
  const note = document.getElementById("note");
  note.textContent = modeNote + filteredReason;

  // Round labels
  function labelRound(ix,total){
    if(total===1) return "Final";
    if(total===2) return ix===0?"Semifinals":"Final";
    if(total===3) return ["Quarterfinals","Semifinals","Final"][ix];
    if(total===4) return ["Round 1","Quarterfinals","Semifinals","Final"][ix];
    return "Round " + (ix+1);
  }

  function render(){
    const season = sel.value;
    const gs = playoffGames.filter(g=>g.season===season);
