<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Owner Guessing Game</title>
<style>
:root { --bg:#0f0f10; --card:#1b1b1d; --card2:#141416; --hover:#252528; --text:#fff; --line:#26262a; --muted:#9aa0a6; --accent:#a0c4ff; }
*{box-sizing:border-box}
body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--text)}
/* minimal header – no tabs so page stays hidden */
.sitebar{position:sticky;top:0;z-index:10;width:100%;backdrop-filter:blur(8px);background:rgba(15,15,16,.85);border-bottom:1px solid var(--line)}
.bar-inner{margin:0 auto;max-width:900px;padding:12px 16px;display:flex;gap:12px;align-items:center;justify-content:space-between}
.brand{font-weight:700}
.back a{color:var(--accent);text-decoration:none;border:1px solid var(--line);padding:6px 10px;border-radius:10px}
.back a:hover{background:var(--hover)}
.wrap{max-width:900px;margin:24px auto;padding:0 16px}
h1{margin:8px 0 12px}
.controls{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin:8px 0 16px}
select,input[type="number"],input[type="checkbox"]{background:#121214;color:var(--text);border:1px solid #2a2a2e;border-radius:10px;padding:8px 10px}
.card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:16px;box-shadow:0 8px 20px rgba(0,0,0,.2)}
.big{font-size:28px;font-weight:700;margin:2px 0 10px;line-height:1.2}
.sub{color:#cbd5e1;font-size:13px;margin-bottom:8px}
.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
input[type="text"]{background:#121214;border:1px solid #2a2a2e;border-radius:10px;padding:10px 12px;color:var(--text);min-width:200px}
.btn{color:var(--accent);text-decoration:none;border:1px solid var(--line);padding:8px 10px;border-radius:10px;cursor:pointer;background:transparent}
.btn:hover{background:var(--hover)}
.stats{display:flex;gap:12px;flex-wrap:wrap;color:#cbd5e1;font-size:13px;margin-top:8px}
.good{color:#86efac} .bad{color:#fda4af} .muted{color:var(--muted)}
hr{border:none;border-top:1px solid #202024;margin:16px 0}
footer{margin:24px 0 36px;color:var(--muted);font-size:12px}
kbd{padding:1px 6px;border:1px solid #2a2a2e;border-bottom-width:2px;border-radius:6px;background:#111}
.tag{display:inline-block;border:1px solid #2a2a2e;border-radius:999px;padding:1px 8px;font-size:11px;margin-left:8px;opacity:.9}
</style>
</head>
<body>
<div class="sitebar">
  <div class="bar-inner">
    <div class="brand">Season Ending Roster</div>
    <div class="back"><a href="index.html">← Back</a></div>
  </div>
</div>

<div class="wrap">
  <h1>Guess the Owner</h1>
  <div class="controls">
    <label>Season from <input id="minSeason" type="number" style="width:90px"></label>
    <label>to <input id="maxSeason" type="number" style="width:90px"></label>
    <label><input id="uniqueTeams" type="checkbox" checked> Use unique team names</label>
    <button class="btn" id="rebuild">Rebuild deck</button>
    <span class="muted" id="srcNote"></span>
  </div>

  <div class="card" id="game">
    <div class="sub">Team</div>
    <div class="big" id="teamName">—</div>
    <div class="sub" id="meta">—</div>

    <div class="row">
      <input id="guess" type="text" placeholder="Type the franchise owner and press Enter…"/>
      <button class="btn" id="check">Check</button>
      <button class="btn" id="hint">Hint</button>
      <button class="btn" id="reveal">Reveal</button>
      <button class="btn" id="next">Next</button>
    </div>

    <div class="stats">
      <span>Score: <strong id="score">0</strong></span>
      <span>Streak: <strong id="streak">0</strong> <span class="muted">(best <span id="best">0</span>)</span></span>
      <span>Accuracy: <strong id="acc">—</strong></span>
      <span class="muted">Deck size: <span id="deckSize">0</span></span>
    </div>

    <div id="result" class="sub" style="margin-top:10px"></div>
  </div>

  <footer>
    • Answer with full owner name or a <em>unique</em> first name.  
    • Keyboard: <kbd>Enter</kbd> check, <kbd>Shift</kbd>+<kbd>Enter</kbd> next, <kbd>?</kbd> hint.
  </footer>
</div>

<script>
(async function(){
  // Try processed and proccessed
  const CAND = (p)=>[
    `data/processed/${p}`, `/data/processed/${p}`,
    `data/proccessed/${p}`, `/data/proccessed/${p}`
  ];

  // --- utils
  async function fetchText(paths){
    for(const p of paths){ try{ const r=await fetch(p,{cache:'no-store'}); if(r.ok) return {text:await r.text(), path:p}; }catch{} }
    return {text:null, path:null};
  }
  function parseCSV(text){
    const rows=[]; let cur="", q=false, i=0; const push=()=>{rows[rows.length-1].push(cur);cur="";}; const start=()=>rows.push([]); start();
    while(i<text.length){ const c=text[i++]; if(q){ if(c=='"'){ if(text[i]=='"'){cur+='"';i++;} else q=false; } else cur+=c; }
      else{ if(c=='"') q=true; else if(c==',') push(); else if(c=='\r'){} else if(c=='\n'){push();start();} else cur+=c; } }
    if(cur!==""||rows[rows.length-1].length) push(); if(rows[rows.length-1].length===0) rows.pop();
    const header=rows.shift()||[]; return rows.map(r=>Object.fromEntries(header.map((h,j)=>[h, r[j]??""])));
  }
  const norm = s => String(s||"").toLowerCase().replace(/[^a-z0-9]/g,"").trim();

  // --- load standings (team_name + owner + season)
  const s = await fetchText(CAND("standings_by_season.csv"));
  const srcNote = document.getElementById('srcNote');
  if(!s.text){ document.getElementById('teamName').textContent="Could not load standings_by_season.csv"; return; }
  srcNote.textContent = "Data: " + s.path.replace(location.origin,"");
  const rows = parseCSV(s.text).filter(r => (r.team_name||"").trim() && (r.franchise_owner||r.owner||"").trim());

  // seasons
  const seasons = [...new Set(rows.map(r => r.season))].map(n => +n).sort((a,b)=>a-b);
  const minSeasonEl = document.getElementById('minSeason');
  const maxSeasonEl = document.getElementById('maxSeason');
  minSeasonEl.value = seasons[0] || "";
  maxSeasonEl.value = seasons[seasons.length-1] || "";

  // all owners + first-name uniqueness for forgiving answers
  const owners = [...new Set(rows.map(r => (r.franchise_owner || r.owner || "").trim()))];
  const firstMap = {};
  owners.forEach(o => {
    const first = (o.split(/\s+/)[0] || o).toLowerCase();
    (firstMap[first] ||= new Set()).add(o);
  });

  // make deck from rows
  function buildDeck(){
    const lo = +minSeasonEl.value || seasons[0];
    const hi = +maxSeasonEl.value || seasons[seasons.length-1];
    const filtered = rows.filter(r => +r.season >= lo && +r.season <= hi);

    // team -> {owner -> count, seasons:Set}
    const map = {};
    for(const r of filtered){
      const t = (r.team_name||"").trim();
      const o = (r.franchise_owner || r.owner || "").trim();
      if(!map[t]) map[t] = {owners:{}, seasons:new Set()};
      map[t].owners[o] = (map[t].owners[o]||0)+1;
      map[t].seasons.add(r.season);
    }

    const uniqueOnly = document.getElementById('uniqueTeams').checked;
    let deck = [];

    if (uniqueOnly) {
      for (const [team, obj] of Object.entries(map)){
        const entries = Object.entries(obj.owners).sort((a,b)=>b[1]-a[1]); // most common owner
        const owner = entries[0]?.[0] || "";
        deck.push({ team, owner, count: entries[0]?.[1]||0, seasons:[...obj.seasons].sort(), owners: obj.owners });
      }
    } else {
      // include each appearance (harder)
      for (const r of filtered){
        deck.push({ team:r.team_name.trim(), owner:(r.franchise_owner||r.owner||"").trim(), count:1, seasons:[r.season], owners:{[(r.franchise_owner||r.owner).trim()]:1} });
      }
      // shuffle
      for(let i=deck.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [deck[i],deck[j]]=[deck[j],deck[i]]; }
    }
    return deck;
  }

  // game state
  let deck = buildDeck();
  let idx = -1;
  let score=0, attempts=0, streak=0, best=+(localStorage.getItem('ser_best_streak')||0);
  const teamEl = document.getElementById('teamName');
  const metaEl = document.getElementById('meta');
  const guessEl = document.getElementById('guess');
  const resEl = document.getElementById('result');
  const scoreEl=document.getElementById('score'), streakEl=document.getElementById('streak'), bestEl=document.getElementById('best'), accEl=document.getElementById('acc'), deckSizeEl=document.getElementById('deckSize');
  bestEl.textContent = best; deckSizeEl.textContent = deck.length;

  function pick(){
    if(deck.length===0){ teamEl.textContent="No cards in deck."; metaEl.textContent="Adjust filters above."; return; }
    idx = Math.floor(Math.random()*deck.length);
    const c = deck[idx];
    teamEl.textContent = c.team;
    metaEl.innerHTML = `Seen in <strong>${c.seasons.length}</strong> season${c.seasons.length>1?"s":""} <span class="tag">from ${c.seasons[0]}–${c.seasons[c.seasons.length-1]}</span>`;
    guessEl.value=""; guessEl.focus();
    resEl.textContent="";
  }
  function updateStats(){
    scoreEl.textContent=score; streakEl.textContent=streak;
    accEl.textContent = attempts? ((score/attempts)*100).toFixed(1)+'%':'—';
    if (streak>best){ best=streak; bestEl.textContent=best; localStorage.setItem('ser_best_streak', String(best)); }
  }

  function acceptableAnswersFor(owner){
    const full = owner;
    const first = (owner.split(/\s+/)[0]||owner).toLowerCase();
    const answers = new Set([norm(full)]);
    // allow unique first name
    if (first && firstMap[first] && firstMap[first].size === 1) answers.add(norm(first));
    return answers;
  }

  function check(){
    if (idx<0) return;
    const c = deck[idx];
    const a = norm(guessEl.value);
    const okSet = acceptableAnswersFor(c.owner);
    const ok = okSet.has(a);
    attempts++;
    if (ok){
      score++; streak++;
      resEl.innerHTML = `<span class="good">Correct!</span> It was <strong>${c.owner}</strong>.`;
      // remove this card from deck for variety
      deck.splice(idx,1); deckSizeEl.textContent = deck.length;
    } else {
      streak = 0;
      // show a gentle nudge (owners with same first name if ambiguous)
      const first = (c.owner.split(/\s+/)[0]||c.owner).toLowerCase();
      const isAmbig = first && firstMap[first] && firstMap[first].size>1;
      const hint = isAmbig ? ` (first name “${first}” is ambiguous)` : ``;
      resEl.innerHTML = `<span class="bad">Nope.</span> Answer: <strong>${c.owner}</strong>${hint}`;
    }
    updateStats();
  }

  function hint(){
    if (idx<0) return;
    const c = deck[idx];
    const first = c.owner.split(/\s+/)[0]||c.owner;
    resEl.innerHTML = `Hint: starts with <strong>${first[0].toUpperCase()}</strong>…`;
    guessEl.focus();
  }

  // wire UI
  document.getElementById('check').addEventListener('click', check);
  document.getElementById('reveal').addEventListener('click', () => { if(idx>=0){ resEl.innerHTML = `It was <strong>${deck[idx].owner}</strong>.`; streak=0; updateStats(); } });
  document.getElementById('next').addEventListener('click', pick);
  document.getElementById('hint').addEventListener('click', hint);
  document.getElementById('rebuild').addEventListener('click', () => { deck = buildDeck(); deckSizeEl.textContent = deck.length; pick(); });
  document.getElementById('uniqueTeams').addEventListener('change', () => { deck = buildDeck(); deckSizeEl.textContent = deck.length; pick(); });
  minSeasonEl.addEventListener('change', () => { deck = buildDeck(); deckSizeEl.textContent = deck.length; pick(); });
  maxSeasonEl.addEventListener('change', () => { deck = buildDeck(); deckSizeEl.textContent = deck.length; pick(); });

  // keyboard shortcuts
  guessEl.addEventListener('keydown', (e)=>{
    if (e.key==='Enter' && !e.shiftKey){ check(); }
    if (e.key==='Enter' && e.shiftKey){ pick(); }
    if (e.key==='?' || (e.shiftKey && e.key.toLowerCase()==='/' )){ e.preventDefault(); hint(); }
  });

  pick();
})();
</script>
</body>
</html>
